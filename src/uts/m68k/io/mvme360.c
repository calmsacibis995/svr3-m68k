/*	@(#)mvme360.c	7.8 	*/
/*
 *	Copyright (c) 1985	Motorola Inc.  
 *		All Rights Reserved.
 */
/*
 *	MVME360 Driver: This driver is for Motorola's MVME360 Storage Module
 *		Drive Disk controller. The MVME360 is a VMEbus compatible
 *		board with multiple drive capabilities. The MVME360 has an
 *		MC68000 on board to perform intelligent disk control.
 *		The MVME360 supports two SMD-compatible disk drives and
 *		has no floppy disk support.
 */

/*
 *	DEBUG support
 */

#define COALES
short	m360coal = 1;		/* enable/disable block I/O coalescing */
short	cprthresh = 15;		/* threshold which suppresses coalesce message*/

#define DEBUG
#undef DEBUG

#define	DEBUGC			/* command debugging */

#ifdef	DEBUG

#define	STATIC

int	DebugM360 = DEBUG;	/*	0 -> no debug print outs */
				/*	1 -> init/open/close/read/write/dump */
				/*	2 -> 1 plus strategy/config */
				/*	3 -> 2 plus start/clr/cmd */
				/*	4 -> 3 plus intr */
				/*	5 -> 4 plus timeout */
				/*	6 -> 5 and verbose */

#else

#define	STATIC	static

#endif


/*
 *	This driver will support up to 2 controllers
 *	Each MVME360 can control up to 2 drives simultaneously:
 *
 *	Logical Unit Number   Drive	Device
 *		(LUN)
 *
 *		 0		0	Drive 0 - fixed
 *		 1		0	Drive 0 - cartridge
 *		 2		1	Drive 1 - fixed
 *		 3		1	Drive 1 - cartridge
 */

#define	MAXDEV	2		/* up to 2 devices per controller */
#define	MAXHRD	2		/* maximum hard disks per controller */
#define	MAXLUN	4		/* up to 4 logical units */

STATIC	unsigned m360_ctls;

/* maximum number of slots */
#define	MAXPOS	(m360_ctls*MAXDEV)

/* maximum number of logical slots */
#define	MAXLPOS	(m360_ctls*MAXLUN)

/* address modifier */
STATIC unsigned char m360adrm;

/* global memory type */
STATIC unsigned char m360mtyp;

#ifdef DEBUG
	int m360io16b = 0;		/* counter for 16 bit data xfers */
	int m360io32b = 0;		/* counter for 32 bit data xfers */
#endif

/*
 *	MVME360 Disk Controller Driver Minor Number Assignment Coding
 *
 *		 <-   1    -> <- 2 -> <- 1 -> <-   1   -> <- 3 ->
 *		 ------------------------------------------------
 *		| controller | zeros | drive | volume | slice |
 *		 ------------------------------------------------
 *
 *							Standard Names
 *   Minor Number    Logical				 Controller
 *   (in octal)       Unit 	Drive			0 Name	   1 Name
 *	000X		0	Drive 0 Fixed		m360_0sX  m360_c1d0sX
 *	001X		1	Drive 0 Cartridge	m360_1sX  m360_c1d1sX
 *	002X		2	Drive 1 Fixed		m360_2sX  m360_c1d2sX
 *	003X		3	Drive 1 Cartridge	m360_3sX  m360_c1d3sX
 */

#define	SLICE(d)	(d&0x7)		/* minor -> slice */
#define	UNIT(d)		((d>>4)&0x1)	/* minor -> unit (phys drive) */
#define	MKDEV(c,u)	((c<<7)|(u<<4))	/* ctl/unit -> minor number */
#define	CTL(d)		((d&0x80)>>7)	/* controller number */
#define	POS(d)		(((d&0x80)>>6)|UNIT(d)) /* position in m360utab */

#define	LUN(d)		((d>>3)&0x3)	/* logical unit */
#define	LPOS(d)		((CTL(d)*MAXLUN)+LUN(d)) /* logical position */

#define	RMVBL(d)	(d&8)		/* removable media */
#define	FIXED(d)	(!RMVBL(d))	/* fixed media */
#define	VOL(d)		((d>>3)&1)	/* volume number */
#define OTHERVOL(v)	(v^1)		/* other volume number */
#define	MKOPDEV(d)	((d&0x18)<<3)	/* make command option device */
#define	MKOPUN(d)	((d&0x10)<<3)	/* make command option unit number */
#define	SCDRV(s)	((s>>3)&1)	/* status change drive */
#define	COPTOU(x)	((x>>7)&1)	/* command option unit */
#define	COPTOV(x)	((x>>6)&1)	/* command option volume */

#define SGLIST(d)	(&m360sglist[LPOS(d) * M360MXCOAL])
#define	ILLEGAL(d)	((POS(d)>m360_cnt)||((d)&0x60)) /* illegal minor dev */

/* Macros to generate block offset of I/O for error logging */
#define SECPBLK		(BSIZE/((struct m360uib *)dp->uib)->ib_bps) /* sectors/block */
#define IO_BOFF		(bp->b_blkno+(int)bp->soff/SECPBLK) /* I/O blk offset */

/*
 *	MVME360 Disk Controller Constants
 */

/*	Drive Status Register	*/
#define DSTAT(d,s)	((d)?(s>>8&0xff):(s&0xff))	/* drive status */
/*	Signals from the drive	*/
#define DRV_RDY 	0x01	/* Drive Ready - up to speed & ready to go */
#define WRT_PROT	0x02	/* Write Protected - at current cylinder */
#define DRV_BUSY	0x04	/* Drive Busy - dual ported drive only */
#define FAULT   	0x08	/* Drive Fault - controller violated spec */
#define ON_CYL   	0x10	/* On Cylinder */
#define SEEK_ERR	0x20	/* Seek Error */
/*	Calculated or generated by the controller */
#define UNIT_PRS	0x40	/* Unit Present - responded to select */
#define UNIT_RDY	0x80	/* Unit Ready - on cylinder & no faults */

/*	Command/Status Register	*/
#define SCHG_SRC	0x08	/* Status Change Source - interrupting drive */
#define ERR_LCMD	0x10	/* Error Last Command */
#define SCHG_INT	0x20	/* Status Change Interrupt */
#define DONE_INT	0x40	/* Command Completion Interrupt */
#define GO_BUSY		0x80	/* Go/Busy - start command execution */
#define M360BERR	0x0100	/* Bus error during controller memory access */
#define M360BDCL	0x1000	/* Board clear */
#define M360NOSF	0x2000	/* No sysfail on board fail */
#define M360BDOK	0x4000	/* Board passes power up diagnostics */
#define M360SLED	0x8000	/* Status LED static mode */

 /* MVME360 memory type codes */
#define MEMT08		0	/* byte wide (8 bit ) data transfers */
#define MEMT16		2	/* word wide (16 bit ) data transfers */
#define MEMT32		3	/* long wide (32 bit ) data transfers */

/*
 *	MVME360 Command Codes
 */

/*   command name	code		comment 	*/
#define	DIAGNOS		0x70	/* Execute power up diagnostics */
#define	READ_LNG	0x71	/* Reads data & ECC for diagnostics */
#define	WRIT_LNG	0x72	/* Writes data & ECC for diagnostics */
#define	READ_HDR	0x74	/* Reads random header on current cyl */
#define	GET_CNFG	0x77	/* Returns effective driver parameters (UIB) */

#define	WRIT_SBF	0x78	/* Write diagnostic sector to controller */
#define	READ_SBF	0x79	/* Read sector written with WRIT_SBF */
#define	READ_SEC	0x81	/* Read sector(s) */
#define	WRIT_SEC	0x82	/* Write sector(s) */
#define	VRFY_SEC	0x83	/* Verify sector(s) readable without error */

#define	FMT_TRK		0x84	/* Format track */
#define	MAP_TRAK	0x85	/* Format out bad track on drive */
#define	HNDSHAKE	0x86	/* Handshake controller */
#define	INIT_DRV	0x87	/* Initialize drive parameters */
#define	RESTORE 	0x89	/* Attempts to clear drive fault(s) */
#define	SEEK	 	0x8a	/* Seek to specified position */

#define	REFORMAT	0x8b	/* Format track saving bad spot mapping */
#define	FMT_TRKD	0x8C	/* Format track with data */
#define	MAP_SECT	0x90	/* Format out bad sector on track */
#define	READ_NOC	0x94	/* Read sectors ignoring cache buffer */
#define	VRFY_TRK	0x99	/* Verify track readable without error */
#define	TRACK_ID	0x9a	/* Diagnostic returns track header info */
#define	FETCH_EX	0x9b	/* Fetch IOPB and execute */

#define SCATTER		0xa1	/* Read to non-contiguous memory */
#define GATHER 		0xa2	/* Write from non-contiguous memory */
/*
 *	MVME360 Command Options
 */

#define	ECC_EN		0x01	/* ECC enable */
#define	INT_EN		0x02	/* Interrupt enable */
#define	NOERRCHK	0x04	/* Disables error check on read */
#define	RES_DUAL	0x08	/* Reserves dual ported disk */
#define	LOGICAL		0x10	/* Expect and use logical sector values */
#define	LINK_IOPB	0x20	/* Next IOPB is linked to this one */
#define	VOLUME		0x40	/* Logical volume on specified drive */
#define	DRIVE		0x80	/* Physical drive for command */

#define FMT_PATT	0x1234	/* Format pattern used for:  Format track */
#define FMT_PATM	0xABCD	/* Format pattern used for:  Map alt track */
#define FMT_PATS	0xF00D	/* Format pattern used for:  Sector slip */
#define FMT_PATR	0xF00D	/* Format pattern used for:  Reformat */


/*
 *	MVME360 Status Codes
 */

#define	DONE_OK		0x80	/* Command completed with no error */
#define	BUSY_OK		0x81	/* Command in progress */
#define	DONE_ERR	0x82	/* Command completed with error */
#define	DONE_EXC	0x83	/* Command completed with exception */
#define	UNSTARTED	0	/* Command unstarted, no ctlr status code */

/*
 *	MVME360 Error Codes For Commands Completed With Exception
 */

#define	RETRIES(s)	(s&0xf) /* Retries field from error code where */
/* value 0xf indicates 15 or more depending on count specified in UIB */

#define	RES_USED	0x10	/* Restore and reseek used */
#define	BAD_DATA	0x40	/* Bad data moved to system memory */
#define	ECC_USED	0x80	/* ECC used to correct bad data */

/*
 *	MVME360 Error Codes For Commands Completed With Error
 */

#define	DRV_NRDY	0x10	/* Drive not ready */
#define	SEEK_CYL	0x12	/* Seek error - wrong cylinder */
#define	ECC_CODE	0x13	/* ECC code discrpancy */
#define	BAD_CMD		0x14	/* Invalid command code (byte 0 of IOPB) */
#define	BAD_FEX		0x15	/* Illegal fetch and execute attempted */
#define	BIG_SNUM	0x16	/* Sector number too large for drive */
#define	MEM_TYPE	0x17	/* Illegal memory type specified */

#define	BUS_TOUT	0x18	/* Bus not available in < 1 ms */
#define	HDR_CHKS	0x19	/* Header checksum error */
#define	WRT_PERR	0x1a	/* Disk write protected */
#define	NOT_SEL		0x1b	/* No response from unit on select */
#define	SERR_TOUT	0x1c	/* No correct seek in 3 secs after RESTORE */
#define	FLT_TOUT	0x1d	/* Fault not cleared 3 secs after RESTORE */
#define	DRV_FLT		0x1e	/* Drive fault occured, RESTORE required */
#define	RDY_TOUT	0x1f	/* Drive not ready 3 secs after RESTORE */

#define	PAST_END	0x20	/* Multi sector I/O exceeded end of media */
#define	UIB_ZERO	0x21	/* Uib for specified volume contains zeros */
#define	HDR_PAD		0x22	/* Bad post header pad byte found */
#define	FIX_FAIL	0x23	/* Failed to fix uncorrectable error */
#define	BAD_CYLX	0x24	/* Logical sector num -> bad cylinder num */
#define	BAD_HDX		0x25	/* Logical sector num -> bad head num */
#define	BAD_SECX	0x26	/* Logical sector num -> bad phys sector num */
#define	OVERRUN		0x27	/* Data overrun - suspect clock from drive */


#define	NO_INDEX	0x28	/* No index pulse after 65ms on format cmd */
#define	SEC_NFND	0x29	/* Sector not found during read or write */
#define	BAD_HDNO	0x2a	/* Head number in header wrong */
#define	DATA_SYNC	0x2b	/* Sync word in data field not valid */
#define	SEEK_TOUT	0x2d	/* Seek not complete in 500ms */
#define	BUSY_TOUT	0x2e	/* Drive held by dual port over 500ms */
#define	OFF_CYL		0x2f	/* Not on cylinder in 3 secs after select */

#define	RTZ_TOUT	0x30	/* Not normal complete 3 secs after RESTORE */
#define	HDR_SYNC	0x31	/* Sync word in header not valid */

#define	NOT_INIT	0x40	/* Write or format attempted before INIT_DRV */
#define	SMALL_GAP	0x42	/* Specified gap too small - minimun gap is 5 */
#define	SEEK_DRV	0x4b	/* Seek error reported by drive */
#define	MAP_NOP		0x4c	/* No sector pulse on track to be mapped */

#define	BAD_SPT		0x50	/* Sectors per track in UIB invalid */
#define	BIG_SEC		0x51	/* Bytes per sector in UIB > buffer size */
#define	BAD_ILV		0x52	/* Invalid interleave in UIB > SPT or 0 */
#define	HEAD_OR		0x53	/* Head number in IOPB out of range per UIB */
#define	CYL_OR		0x54	/* Cylinder no. in IOPB out of range per UIB */

#define	IOPB_FAIL	0x60	/* Bus error on external IOPB transfer */
#define	DMA_FAIL	0x61	/* Bus error on DMA transfer */
#define	ALLIGN		0x62	/* VME buffer address not alligned */
				/* Word allign 8 & 16 bit transfers */
				/* Long word allign 32 bit transfers */
#define	NOSPARE		0x6e	/* Spare sector already in use */
#define	NOSPARES	0x6f	/* UIB indicates no spares enabled */

#define	NOT_YET		0xff	/* Command not implemented */

/*
 * 	The following error codes are not used or require support
 * 	directly from Motorola.
 *
 *	Codes not used: 11, 2c, 32-3f, 41, 43-4a, 4e, 4f, 55-5c, 70-ef.
 *
 *	Call Motorola with IOPB and UIB info for error codes f0-fe.
 */

/*
 *	Diagnostic Message Constants and Strings
 */

#define	WORDMSB	15
#define	BYTEMSB	7
#define CSRMSK	0xf1e0
#define DRVSMSK	0xff
#define RTRYMSK	0x0f
#define EXCPMSK	0xf0
#define COPMSK	0x3f
#define ATRMSK	0x7f

static char *csrdis[16] = {	/* control and status register */
	0,0,0,0, 	" err_last", 
	0,		" done",
	" go_busy",	" berr",
	0,0,0, 		" bdclr",
	" sfdis",	" bok",
	" sled"
	};

static char *dstatdis[8] = {	/* drive status */
	" drv_rdy",	" wrt_prot",
	" drv_busy", 	" fault",
	" on_cyl", 	" seek_err",
	" unit_pres", 	" unit_rdy"
	};

static char *excode[8] = {	/* exception codes */
	0,0,0,0,
	" restore_&_reseek",
	" reserve_bit_set",
	" data_may_be_erroneous",
	" ECC_used",
	};

static char *copdis[8] = {	/* command options */
	" ECC_on",		" ints_on",
	" no_error_chk",	" hold_port",
	" logical",		" linked_iopb",
	0,0
	};

static char *atrdis[8] = {	/* attributes */
	" reseek_on",		" bad_data_on",
	" inc_by_head",		" dual_port",
	" SC_int_on",		" CE",
	" SSE",			0
	};

/*
 *	Include files
 */

#include "sys/param.h"
#include "sys/types.h"
#include "sys/sysmacros.h"
#include "sys/fs/s5dir.h"
#include "sys/signal.h"
#include "sys/user.h"
#include "sys/errno.h"
#include "sys/buf.h"
#include "sys/elog.h"
#include "sys/iobuf.h"
#include "sys/systm.h"
#include "sys/dk.h"

#define	MVME360
#include "sys/mvme360.h"

typedef unsigned char u_char;

/*
 *		MVME360 Addresses and vectors
 *
 *	Switch settings 	Board Number	Base Address
 *	8 7 6 5 4 3 2 1
 *	o o o o o x x o		     0		0xffff0c00
 *	o o o o o x x x		     1		0xffff0e00
 *
 *	o = on  x = off 
 *
 *	Although the MVME360 controller can use different interrupt
 *	vectors for normal and error interrupts, the Unix driver is
 *	no less efficient using only one per controller and will use
 *	the vector assigned to normal completion.
 *
 *	Controller	Vector	Address		Comment
 *	    0		0xf9	0x3e4	Normal or only vector
 *	    0		0xf8	0x3e0	Error vector (when used)
 *	    1		0xf7	0x3dc	Normal or only vector
 *	    1		0xf6	0x3d8	Error vector (when used)
 */


/*
 *	External Variables
 */

extern struct device *m360_addr[];
extern int m360_bmaj;			/* block major */
extern int m360_cnt;			/* count */
extern int m360_ilev[];			/* interrupt level */
extern int m360_ivec[];			/* interrupt vector */
extern struct m360list m360sglist[];	/* scatter/gather list array */

struct size
{	daddr_t	nblocks;
	int	cyloff;
};

/*
 *	Driver Variables
 *
 *	Declared in conf.c (space.h or io.h)
 */

extern struct size m360_sizes[][8];
 
extern struct m360ctlr	m360ctlr[];	/* per controller control structure */
extern struct	iotime	m360stat[];	/* one per drive */
extern struct	iobuf	m360utab[];	/* one per drive */
extern struct m360uib	m360uib[];	/* unit init blocks, one per drive */
extern struct m360config m360config[];	/* per volume configuration info */
extern struct m360config m360dfcf[];	/* default configurations */
extern unsigned char m360types[];	/* disk types */
extern struct m360eregs	m360eregs[];	/* per ctlr error log "registers" */


/*
 *	Constants for m360timer
 */

#define	wtime	io_s9
#define	WOK	0
#define	WABORT	1
#define	WERR	20
#define	WSECS	5

#define	WSTART	0	/* start timer */
#define	WCONT	1	/* continue timer */

/*
 *	defines for buf and iobuf structures
 */

#define	acts	io_s1		/* used for sorting I/O queue */
#define	qcnt	io_s2		/* length of I/O queue */
#define	sopen	io_s3		/* open slices */
#define	uib	io_s4		/* pointer to the unit init block (uib) */
#define	dstat	io_s5		/* drive status */
#define	cmdbuf	io_s7		/* pointer to I/O parameter block (iopb) */
/*
 *	Note: io_s5, io_s6 and io_s8 are normally used for 
 *	software bad block handling and continuation I/O.
 *	Neither is needed in this driver since bad spot mapping
 *	is done by the hardware and no multi-formatted disks 
 *	(i.e. floppies with track 0 single density and others double)
 *	are supported.
 */

#define	cylin	b_umd		/* holds cylinder number */
#define	soff	b_s1		/* holds sector offset of slice for I/O */

/* b_flags constants */
#define	B_CONF	0x040000	/* need to perform configuration on volume 0 */
#define	B_CONFR	0x080000	/* need to perform configuration on volume 1 */
#define	B_FMTU	0x100000	/* format unit */
#define	B_SPECL	0x200000	/* rootdev, swapdev, or pipedev */
#define	B_FMTA	0x400000	/* format alternate track */
#define B_FMTS  0x800000	/* format with sector slip */
#define B_RFMT  0x1000000	/* reformat */

/* identify all non read/write I/O commands for correct I/O time accounting */  
#define NON_RWIO  B_CONF|B_CONFR|B_FMTU|B_FMTA|B_FMTS|B_RFMT 


/*
 *	Other constants and defines
 */

#define TRUE	1		/* Generic Booleans */
#define FALSE	0
#define ON	1
#define OFF	0

#define OKAY	0		/* non-error return value */
#define ERRET	-1		/* error return value */

#define	RETRY	10		/* hardware retry count */
#define NORETRY 1		/* only one try */
#define TRYCNT	5		/* default software try count */


#define	STEPSIZE 32		/* I/O queue step */
#define	READ_ONLY -1

#define DMA_CNT 8		/* DMA holds bus for 8 transfers: see note */
/*
 * DMA Note: an unwritten rule of thumb for the VMEbus requires every bus master
 * to give up the bus once every 8 microseconds.  Another unwritten rule
 * says any bus master should be able to withstand 64us of bus inaccess.
 * Eight (8) transfers at an estimated 1.5us per transfer is 12us.
 * This also allows for several bus masters to take a turn at getting the
 * bus for 8us before any one times out.
 */

/* address modifier code factors */
#define DATA_ACC	1	/* data access */
#define SUPERVSR	4	/* supervisor mode */
#define STD_24		0x38	/* standard 24-bit address */
#define EXT_32		0x08	/* extended 32-bit address */

#define LONGMSK		3	/* mask to identify long allignment */

#define	PROC020		682	/* cputype == 682 if M68020 */

/*
 *	Assumptions, conventions and operational notes.
 */

	/* NOTE:
	 * the following variables are currently set once at initialization 
	 * time and are expected to remain untouched throughout operation.
	 * This is reasonable for currently supported commands and is subject
	 * to change.
	 *	In the IOPB:
	 *		pb_ilev		{ interrupt level }
	 *		pb_eivec	{ error interrupt vector }
	 *		pb_nivec	{ normal interrupt vector }
	 *		pb_dmac		{ dma burst length }
	 *		pb_skew		{ uib skew override }
	 *		pb_iopbp	{ linked iopb pointer }
	 *		pb_imtyp	{ linked iopb memory type }
	 *		pb_iamod	{ linked iopb address modifier }
	 *	In the UIB
	 *		ib_silev	{ status change interrupt level }
	 *		ib_sivec	{ status change interrupt vector }
	 *		ib_attrib	{ attributes }
	 */		

	 /*
	  *	For cpytype 682, 68020 systems a 32 bit data bus is assumed
	  *	else 16 bit bus assumed.
	  */

struct device {
	unsigned char	ds[2];	/* drive status for two drives */
	ushort		csr;	/* control status register */
	struct m360iopb iopb1;	/* I/O parameter block */
};

#define drv0stat	ds[1]
#define drv1stat	ds[0]


/*
 *	Driver procedures
 *
 *	m360init: initialize driver
 */

m360init()
{	register struct device *rp;
	register struct iobuf *dp;
	register struct m360uib *ibp;
	register struct m360iopb *pbp;
	register struct m360config *cfp;
	register unit;
	register i;
	register pos;

#ifdef	DEBUG
	if( DebugM360 )
		m360print( 0, "init" );
#endif

	if( cputype == PROC020 ) {
		m360adrm = STD_24|SUPERVSR|DATA_ACC;
		m360mtyp = MEMT32;		/* assumption */ 
	} else {
		m360adrm = STD_24|SUPERVSR|DATA_ACC;
		m360mtyp = MEMT16;		/* assumption */ 
	}

	/*
	 *	the number of controllers is equal to
	 *	m360_cnt divided by:
	 *
	 *	- MAXDEV to divide out the drive field of the minor number
	 *	- 2 to divide out the special field of the minor number
	 *	- 8 to divide out the slices field of the minor number
	 */

	m360_ctls = m360_cnt/(MAXDEV*2*8);

	for( i = 0; i < m360_ctls; i++ ) {
		rp = m360_addr[i];
		if( bprobe( rp, READ_ONLY )) {
			/* controller not present */
#ifdef	DEBUG
			if( DebugM360 > 0 )
				m360print(MKDEV(i,0),"Controller not present");
#endif
			unit = m360_ctls;
			m360_ctls = i;
			while( i < unit )
				m360_addr[i++] = NULL;
			break;

		} else {
			/* controller present */
			pos=MAXDEV*i;
			dp = &m360utab[pos];

			/* convert vector address to vector number */
			m360_ivec[i] /= 4;

			/* initialize per physical disk */
			for(unit=0; unit<MAXDEV; dp++, pos++, unit++ ) {

				dp->b_flags = B_CONFR|B_CONF; /* force config */

				/* set up for error logging */
				dp->io_stp = (struct iostat *)&m360stat[pos];
				dp->io_addr = (paddr_t)&m360eregs[i]; 
				dp->io_nreg = M360EREG;

				/* point to device registers and uib */
				pbp = &rp->iopb1;
				dp->cmdbuf = (int)pbp;
				ibp = &m360uib[pos];
				dp->uib = (int)ibp;

				/* set and forget variables in iopb and uib */
				pbp->pb_ilev = ibp->ib_silev = m360_ilev[i];
				pbp->pb_eivec = pbp->pb_nivec = ibp->ib_sivec 
					= m360_ivec[i];
				pbp->pb_dmac = DMA_CNT;
				pbp->pb_skew = 0;	/* skew in uib used */
				ibp->ib_attrib = M360DATR;

				/* no linked iopb's needed */
				pbp->pb_iopbp = (struct m360iopb *) NULL;
				pbp->pb_imtyp = 0;	/* N/U */
				pbp->pb_iamod = 0; 	/* N/U */
			 }
		}
	}
	if( major(rootdev) == m360_bmaj ) {
		m360utab[POS(rootdev)].b_flags |= B_SPECL;
	}
	if( major(swapdev) == m360_bmaj ) {
		m360utab[POS(swapdev)].b_flags |= B_SPECL;
	}
	if( major(pipedev) == m360_bmaj ) {
		m360utab[POS(pipedev)].b_flags |= B_SPECL;
	}
}

/*
 *	m360open: open a drive (called from m360bopen() and m360copen())
 */

STATIC m360open(dev,openmsk)
register dev;
register openmsk;
{	register struct iobuf *dp;
	register iconf;

#ifdef	DEBUG
	if( DebugM360 )
		m360print(dev, "open");
#endif

 	if( CTL(dev) >= m360_ctls || ILLEGAL(dev) ||	
 	    (m360_addr[CTL(dev)] == 0)) {
		u.u_error = ENXIO;
		return;
	}

	dp = &m360utab[POS(dev)];

	while( dp->b_flags&B_OPEN ) {	/* open in progress? */
		sleep(dp,PRIBIO);
	}

	if( VOL(dev) )
		iconf = B_CONFR;
	else
		iconf = B_CONF;

	/* need to configure ? */

	if( dp->b_flags&(iconf) ) {

		dp->b_flags |= B_OPEN;
		if( m360cf(dev,dp) ) {		/* configure device */
			u.u_error = EIO;	/* on error */
			dp->b_flags &= ~B_OPEN; /* abort open */ 
			wakeup(dp);
			return;
		}
		dp->b_flags &= ~(iconf|B_OPEN); /* config & OPEN done */
		wakeup(dp);
	}

	dp->sopen |= openmsk; 		/* mark successful open */
}

/*
 *	m360bopen: perform open on a block device.
 */

m360bopen(dev)
register dev;

{	register openmsk = ( 1 << ((VOL(dev)? 16:0)+SLICE(dev)));

	m360open(dev,openmsk);
}


/*
 *	m360copen: perform open on a character device.
 */

m360copen(dev)
register dev;

{	register openmsk = ( 1 << ((VOL(dev)? 24:8)+SLICE(dev)));

	m360open(dev,openmsk);
}


/*
 *	m360tst: test of ID string in volume ID
 */

STATIC	char	motstring[10] = "MOTOROLA";
STATIC	char	exorstring[10] = "EXORMACS";

STATIC m360tst(vid_mac)
register *vid_mac;
{	register *mot = (int *)motstring;
	register *vd = vid_mac;

	if( *mot++ == *vd++ )
		if( *mot == *vd )
			return(1);
	
	mot = (int *)exorstring;
	if( *mot++ != *vid_mac++ )
		return(0);

	return( *mot == *vid_mac );
}

/*
 *	m360cf: performs a drive configuration.
 *		Returns OKAY if default configure 
 *		was successful else returns ERRET.
 */

STATIC int m360cf(dev,dp)	/* configure device */
register dev;
register struct iobuf *dp;
{	register struct buf *bp;
	register struct m360config *cfp;
	struct buf *geteblk();

#ifdef	DEBUG
	if( DebugM360 > 1 )
		m360print( dev, "cf" );
#endif

	/*
	 *	configure the disk with the default info
	 */

	cfp = &m360dfcf[m360types[LPOS(dev)]];
	if( m360setcf( dev, dp, cfp, 0)) {	/* set default configuration */
		return( ERRET );		/* permission denied */
	}

	dev |= 7;			/* change to slice 7 */

	bp = geteblk();
	bp->b_proc = u.u_procp;
	bp->b_dev = dev;

	/* do default configure */
	bp->b_flags |= B_CONF;		/* configure */
	bp->b_error = 0;
	bp->b_blkno = 0;
	bp->b_bcount = 0;
	m360strategy(bp);
	iowait(bp);
	bp->b_flags &= ~(B_CONF|B_DONE);

	if ( u.u_error ) {
		/* bad news, couldn't even get default config to go */
		brelse(bp);
		return( ERRET );
	}


/* 
 * Note:
 *	When floppy drives are supported, there is code at this
 *	point to read the actual configuration of the drive from
 *	track zero, which is expected to be readable with the defaults.
 *
 *	Since floppy disks are not supported by the MVME360,
 *	that mechanism is not required in this driver.
 *
 *	The configuration for each drive is selected in m360space.h
 *	at kernel link time and m360ioctl functions M360GET and M360SET
 *	may be used to view and modify the drive configurations
 *	dynamically. Of course, the latter must be used judiciously.
 */


	brelse(bp);
	u.u_error = 0;		/* guarantee no error returned here */
				/* at least defaults are in effect */
	return( OKAY );
}

/*
 *   m360setcf: sets configuration parameters for the physical drive 
 *		associated with dev according to the values in the
 *		structure pointed to by cfp. If the request is accepted,
 *		the uib structure pointed to by dp->dconf is modified.
 *		Returns OKAY if change is accepted, else returns ERRET.
 *
 *		If the structure pointed to by cfp is not the
 *		configuration M360NULL and if the change is 
 *		considered compatible with what is already set,
 *		it is accepted. If the change is not compatible
 *		and only the devices indicated by devmsk are open,
 *		the change is accepted and the head values
 *		for the other volume are set to zero, disabling the
 *		other volume.
 *
 *		Devmsk will normally be 0, disallowing any open devices.
 *		When called from m360ioctl(), the devmsk will identify
 *		the one raw device which must be open.
 */

STATIC int m360setcf(dev, dp, cfp, devmsk) /* set configuration parameters */
register dev, devmsk;
register struct iobuf *dp;
register struct m360config *cfp;
{	
	register struct m360uib *ibp = (struct m360uib *)dp->uib;
	register vol = VOL(dev);

#ifdef	DEBUG
	if( DebugM360 > 1 )
		m360print( dev, "setcf" );
#endif

	if( cfp->cf_vsh == M360NLCF )	/* if the config is M360NULL */
		return( ERRET );	/*    reject request	*/

	/* if change is compatible */
		if ( cfp->cf_spt == ibp->ib_spt &&
			cfp->cf_skew == ibp->ib_skew &&
			cfp->cf_bps == ibp->ib_bps &&
			cfp->cf_gap1 == ibp->ib_gap1 &&
			cfp->cf_gap2 == ibp->ib_gap2 &&
			cfp->cf_intlv == ibp->ib_intlv &&
			cfp->cf_cyls == ibp->ib_cyls &&
			(cfp->cf_attrib & M360SSE) == (ibp->ib_attrib & M360SSE)
			) {

		/* set "harmless" and volume specific values */

			ibp->ib_retry = cfp->cf_retry;	/* retry count */
			if( cfp->cf_attrib & M360CEN )	/* cache enable */
				ibp->ib_attrib |= M360CEN;
			else
				ibp->ib_attrib &= ~M360CEN;

			ibp->ib_sh(vol) = cfp->cf_vsh; /* starting head */
			ibp->ib_nh(vol) = cfp->cf_vnh; /* head count */
			return( OKAY );
		};

	if( dp->sopen &  ~(devmsk) )	/* if unexpected device is open */
		return( ERRET );	/* reject request 

	/* otherwise set all user configurable values in uib */
	ibp->ib_spt = cfp->cf_spt;
	ibp->ib_skew = cfp->cf_skew;
	ibp->ib_bps = cfp->cf_bps;
	ibp->ib_gap1 = cfp->cf_gap1;
	ibp->ib_gap2 = cfp->cf_gap2;
	ibp->ib_intlv = cfp->cf_intlv;
	ibp->ib_retry = cfp->cf_retry;
	ibp->ib_cyls = cfp->cf_cyls;
	ibp->ib_attrib &= ~M360UATR;	/* set user setable attributes */
	ibp->ib_attrib |= M360UATR & cfp->cf_attrib;

	/* set heads for this volume */
	ibp->ib_sh(vol) = cfp->cf_vsh;	/* starting head */
	ibp->ib_nh(vol) = cfp->cf_vnh;	/* head count */

	/* disable other volume */
	vol = OTHERVOL(vol);
	ibp->ib_sh(vol) = 0;
	ibp->ib_nh(vol) = 0;

	return( OKAY );

}

/*
 *	m360close: close a device ... only called on the last open.
 *		Watch out for rootdev, swapdev, and pipedev
 *		Called from m360bclose() and m360cclose().
 */

STATIC m360close(dev,openmsk)	/* last close on device */
register dev;
register openmsk;
{	register struct iobuf *dp;
	register pos = POS(dev);

#ifdef	DEBUG
	if( DebugM360 )
		m360print(dev, "close");
#endif

	dp = &m360utab[pos];
	dp->sopen &= ~openmsk;			/* turn off open bit */
	openmsk = dp->sopen;			/* get open bits */
	if( VOL(dev) )
		openmsk &= 0xffff0000;		/* get volume 1 bits */
	else
		openmsk &= 0x0000ffff;		/* get volume 0 bits */

	if( (( dp->b_flags&B_SPECL ) == 0 )	/* not special */
	&&   ( openmsk == 0 ) ) {		/* nothing open */

		/* force reconfigure of removable media next open */
		if( RMVBL( dev ) )
			dp->b_flags |= B_CONFR;
	}
}

/*
 *	m360bclose: close block device
 */

m360bclose(dev)
register dev;

{	register openmsk = ( 1 << ((VOL(dev)? 16:0)+SLICE(dev)));
	
	m360close(dev,openmsk);
}

/*
 *	m360cclose: close character device
 */

m360cclose(dev)
register dev;

{	register openmsk = ( 1 << ((VOL(dev)? 24:8)+SLICE(dev)));
	
	m360close(dev,openmsk);
}

/*
 *	m360strategy: perform disk I/O strategy algorithm.
 *		Call m360start to get the controller started if necessary.
 */

m360strategy(bp)
register struct buf *bp;
{
	register struct iobuf *dp;
	register last, co, dev, seccyl;
	register struct m360ctlr *ctlr;
	register struct iotime *ip;
	static   x;

	register struct m360uib *ibp; 

	dev = bp->b_dev;
#ifdef	DEBUG
	if( DebugM360 > 1 )
		printf("%s on MVME360 ctl %d, drive %d, vol %d, slice %d blk %d\n",
		"strategy", CTL(dev), UNIT(dev), VOL(dev), SLICE(dev), 
		bp->b_blkno);
#endif

	dp = &m360utab[POS(dev)];
	ibp = (struct m360uib *)dp->uib;
	{	register struct size *sp
			= &m360_sizes[m360types[LPOS(dev)]][SLICE(dev)];

		co = sp->cyloff;
		last = sp->nblocks;
	}

	if (bp->b_bcount&(BSIZE-1)) {		/* no partial block I/O */
		bp->b_flags |= B_ERROR;
		bp->b_error = ENXIO;
		iodone(bp);
		return;
	}

	if (bp->b_blkno < 0 || bp->b_blkno >= last ) {
		if (bp->b_blkno == last && bp->b_flags&B_READ)
			bp->b_resid = bp->b_bcount;
		else {
			bp->b_flags |= B_ERROR;
			bp->b_error = ENXIO;
		}
		iodone(bp);
		return;
	}

	bp->av_forw = NULL;
	bp->av_back = NULL;
	bp->b_start = lbolt;


	seccyl = ibp->ib_spt*ibp->ib_nh(VOL(dev));
	bp->cylin = bp->b_blkno*(BSIZE/ibp->ib_bps)/seccyl + co;
	*((int *)(&bp->soff)) = co*seccyl;	/* save sector offset */

	/* log I/O statistics for this drive */
	ip = &m360stat[POS(dev)];

	if( ( bp->b_flags & NON_RWIO) )
		++(ip->io_other);
	else {
		++(ip->io_cnt);	
		ip->io_bcnt += btoc(bp->b_bcount);
	}


	/* put request in buffer queue */
	x = spl6();		/* spl() high enough to block m360timer() */
	if( dp->b_actf == NULL ) {
		dp->b_actf = bp;
		dp->b_actl = bp;
		dp->acts = (int)bp;
	} else {
		register struct buf *ap;
		register struct buf *cp;

		if(((ip->io_cnt)&(STEPSIZE-1)) == 0 )
			dp->acts = (int)dp->b_actl;
		for( ap=(struct buf *)dp->acts; cp=ap->av_forw; ap=cp ) {
			int	s1,s2;

			if ((s1 = ap->cylin - bp->cylin)<0) s1 = -s1;
			if ((s2 = ap->cylin - cp->cylin)<0) s2 = -s2;
			if (s1 < s2)
				break;
		}
#ifdef COALES
		if((m360coal) && (ap != dp->b_actf) 
		&& (trycoales(ap, bp, M360MXCOAL-1,
		 ap->b_bcount/BSIZE ) == 0))
		
			;		/* bp was linked for coalescing */
		else{
					/* bp was not linked for coalescing */
			ap->av_forw = bp;
			if ((bp->av_forw = cp) == NULL)
				dp->b_actl = bp;
		}
#else
		ap->av_forw = bp;
		if ((bp->av_forw = cp) == NULL)
			dp->b_actl = bp;
#endif
	}
	dp->qcnt++;		/* another one in queue */

	ctlr = &m360ctlr[CTL(dev)];
	if( ctlr->cc_actp == NULL ) {	/* controller inactive ? */
		m360start(CTL(dev));
		m360timer(WSTART);	/* start timer */
	}
	splx(x);
}

/* 	trycoales: try to combine individual block I/O requests. 
*	Call under interrupt protection.
*	Caller must assure that "cbp" is NOT the head of the I/O request queue
*    	which may be an I/O request already in progress.
*
*	Requests to be combined are linked together using the "av_back"
*	pointer. 
*
*/
#ifdef COALES
trycoales(cbp, newbp, maxentries, pblocks)
register struct buf *cbp;	/* first bp in list */ 
register struct buf *newbp;	/* try to link this new bp to end of list  */
register int	maxentries;	/* maximum number of bps permitted in list */
register short	pblocks;	/* physical blocks per file system block */
{
  register struct buf *bp;	/* last bp in list */
  register int  entries; 

  if(((cbp->b_flags & B_PHYS) == 0)
  &&((newbp->b_flags & B_PHYS) == 0)
  &&((cbp->b_flags & B_READ) == (newbp->b_flags & B_READ))){

	bp = cbp;
	for( entries=0 ; bp->av_back ; (bp = bp->av_back), entries++)
		;

	if(( entries < maxentries)
	&&(newbp->soff == bp->soff)
	&&(newbp->b_blkno == bp->b_blkno + pblocks)){

		bp->av_back = newbp;

		return(0);	/* Successful */
	}
   }
	return(-1);	/* Unsuccessful */
}
#endif
 		


/*
 *	m360start: start controller
 */

m360start( ctl )
register ctl;

{	register struct buf *bp;
	register struct iobuf *dp, *nextdp;
	register d;

#ifdef	DEBUG
	if( DebugM360 > 2 )
		m360print( MKDEV( ctl, 0), "start");
#endif

 	/* select next device to be serviced */
	dp = (struct iobuf *)NULL; 
	nextdp = &m360utab[MAXDEV*ctl];

	for( d=0; d < MAXDEV; d++, nextdp++ ) {
		if( nextdp->b_actf != NULL ) {
			dp = nextdp;
			break;
		}
	}
	if(( m360ctlr[ctl].cc_actp = dp ) == NULL ) {
		return;		/* if no requests, cc_actp marked idle */
	}
	dp->b_errcnt = TRYCNT;
	m360dstart( dp );
}



/*
 *	m360dstart: start device
 */

m360dstart( dp )
register struct iobuf *dp;
{	 register struct buf *bp;

	bp = dp->b_actf;			/* next request */
#ifdef	DEBUG
	if( DebugM360 > 2 )
		m360print( bp->b_dev, "dstart");
#endif
	dp->b_dev = bp->b_dev;			/* current device */

	if( bp->b_flags&B_CONF ) {		/* B_CONF */
		m360docf(dp,bp);

	} else if( bp->b_flags&(B_FORMAT) ) {	/* B_FORMAT */
		dp->wtime = WERR*4;		/* increase timeout */
		m360format(dp,bp);
	} else {				/* B_READ or B_WRITE */
		/* start I/O segment */
		dp->wtime = WERR;
		bp->b_resid = bp->b_bcount;	/* remaining bytes */
		m360ustart(dp,bp);
	}
}

/*
 *	m360docf: perform actual configuration command
 */

STATIC m360docf(dp,bp)
register struct iobuf *dp;
register struct buf *bp;

{	register struct m360iopb *pbp;
	register dev = bp->b_dev;

#ifdef	DEBUG
	if( DebugM360 > 2 )
		m360print( dev, "docf" );
#endif

	pbp = (struct m360iopb *)dp->cmdbuf;

	/* set up iopb for initialize command */
	pbp->pb_cmd = INIT_DRV;
	pbp->pb_opt = MKOPDEV(dev)|INT_EN;
	pbp->pb_stat = 0;
	pbp->pb_err = 0;
	pbp->pb_lsect = 0;
	pbp->pb_scnt = 0;
	pbp->pb_badr = (char *)&m360uib[POS(dev)];
	pbp->pb_bmtyp = MEMT16;
	pbp->pb_bamod = m360adrm;

	dp->b_errcnt = NORETRY;
	dp->io_start = lbolt;
	m360doit(CTL(dev));
}

/*
 *	m360format: perform actual format command
 */

m360format(dp,bp)
register struct iobuf *dp;
register struct buf *bp;

{
	register struct m360iopb    *pbp;
	register struct m360uib     *ibp;
	register m360fmt *fmtp;
	register dev = bp->b_dev;
	register long seccyl;		/* sectors per cylinder */
	register long secno;		/* sector number */

#ifdef DEBUG
	if  ( DebugM360 > 2 )
	    m360print( dev, "format" );
#endif

	pbp = (struct m360iopb *)dp->cmdbuf;
	ibp = (struct m360uib *)dp->uib;
	fmtp = (m360fmt *)(bp->b_un.b_addr);

	if  ( bp->b_flags & (B_FMTA) ) {  	/* Map alternate track */
		pbp->pb_cmd = MAP_TRAK;
		pbp->pb_altcyl = fmtp->f_alttrk / ibp->ib_nh( VOL(dev) );
		/*  Actual head =  track offset + starting head number */
		pbp->pb_alttrk = fmtp->f_alttrk % ibp->ib_nh( VOL(dev) ); 
		pbp->pb_alttrk += ibp->ib_sh( VOL(dev) );
		pbp->pb_pat = FMT_PATM;
	}
	else if  ( bp->b_flags & (B_RFMT) ) {	/* Reformat track untested*/
		pbp->pb_cmd = MAP_TRAK;
		pbp->pb_pat = FMT_PATR;
	}
	else if  ( bp->b_flags & (B_FMTS) ) {	/* Format with sector slip untested*/
		pbp->pb_cmd = MAP_TRAK;
		pbp->pb_psect = fmtp->f_slpsec;
		pbp->pb_pat = FMT_PATS;
	}
	else {					/* Simple Format */
		pbp->pb_cmd = FMT_TRK;
		pbp->pb_pat = FMT_PATT;
	}

	/*	Set up Common code	*/
	pbp->pb_opt = MKOPUN(dev) | INT_EN ;  /* since no logical translation don't need MKODEV(dev) to give VOL to map sector */
	pbp->pb_stat = 0;
	pbp->pb_err = 0;
	pbp->pb_cyl = fmtp->f_trk / ibp->ib_nh( VOL(dev) );
	/*  Actual head =  track offset + starting head number */
	pbp->pb_trk = fmtp->f_trk % ibp->ib_nh( VOL(dev) ); 
	pbp->pb_trk += ibp->ib_sh( VOL(dev) );

	dp->b_errcnt = NORETRY;
	dp->io_start = lbolt;

	m360doit( CTL(dev) );
}

/*
 *	m360ustart: perform I/O on specified unit
 */

m360ustart(dp,bp)
register struct iobuf *dp;
register struct buf *bp;

{	register struct m360iopb *pbp;
	register struct m360uib *ibp;
	register dev = bp->b_dev;
	register char *  bufaddr;
	register struct buf *nbp;
	register struct m360list *list;
	register int i;

#ifdef	DEBUG
	if( DebugM360 > 2 )
		m360print( dev, "ustart" );
#endif

	pbp = (struct m360iopb *)dp->cmdbuf;
	ibp = (struct m360uib *)dp->uib;


#ifdef COALES
	if(bp->av_back){
		list = (struct m360list *)SGLIST(dev);
		pbp->pb_badr = (char *)list;
		for(nbp = bp, i=0; nbp;
		    (nbp = nbp->av_back), i++, list++){
			list->bcount = nbp->b_bcount;
			list->addr = nbp->b_un.b_addr;
			list->memtype = m360mtyp;  
			list->addrmod = m360adrm;
   		}
		pbp->pb_entries = i;
#ifdef DEBUG
		if(i >cprthresh){
		    if(bp->b_flags&B_READ)
			printf("m360ustart: combined %d read requests\n",i);
		    else
			printf("m360ustart: combined %d write requests\n",i);
		}
#endif
		pbp->pb_scnt = i * (bp->b_resid/ibp->ib_bps);
		pbp->pb_cmd = (bp->b_flags&B_READ)? SCATTER : GATHER;
   	}
	else
	{
#endif
		pbp->pb_badr = bp->b_un.b_addr;
		pbp->pb_cmd = (bp->b_flags&B_READ)? READ_SEC: WRIT_SEC;
		pbp->pb_scnt = bp->b_resid/ibp->ib_bps;
#ifdef COALES
	}
#endif


	pbp->pb_opt = MKOPDEV(dev)|LOGICAL|INT_EN|ECC_EN;
	pbp->pb_stat = 0;
	pbp->pb_err = 0;
	pbp->pb_lsect = (bp->b_blkno*(BSIZE/ibp->ib_bps))+(int)bp->soff;

	/* set memory type and address modifiers */
	if( (int)pbp->pb_badr & LONGMSK ) {	/* if not long alligned */
		pbp->pb_bmtyp = MEMT16;		/* force 16 bit transfer */
#ifdef DEBUG
		m360io16b++;
#endif
	} else {
#ifdef DEBUG
		m360io32b++;
#endif
		pbp->pb_bmtyp = m360mtyp;	/* use specified type */
	}
	pbp->pb_bamod = m360adrm;

	dp->io_start = lbolt;	/* start the clock, this one's ready to go */

	m360doit(CTL(dev));
}

/*
 *	m360doit: initiate command to controller
 */

m360doit(ctl)
register ctl;

{	register csr, dev;
	register struct device *rp;

	dev = MKDEV(ctl,0);
	rp = (struct device *)m360_addr[ctl];

#ifdef	DEBUG
	if( DebugM360 > 2 ) {
		m360print( dev , "doit" );
#ifdef	DEBUGC
		m360prall(rp);
#endif
	}
#endif

	csr = rp->csr;		/* get controller status */

	/* if the board is not ok or the controller is busy */
	if( !(csr & M360BDOK) || (csr & GO_BUSY) ) {
#ifdef	DEBUG
		if( DebugM360 > 2 ) {
			printf("Status = %x\n", csr&0xffff );
		}
#endif
		/* go no further */
		m360print(dev, "not ready" );
		return;
	}

	/* otherwise, set the GO bit among others */

	rp->csr = M360SLED|M360BDOK|M360NOSF|GO_BUSY;
}

/*
 *	m360intr: handle mvme360 interrupts
 */

m360intr(base_dev)
{	register struct device *rp;
	register struct iobuf *dp;
	register struct buf *bp;
	register struct buf *coalbp;
	register struct m360iopb *pbp;
	register ctl, dev, erf=0;
	struct buf	*oldbp;
	int csr;

	ctl = base_dev / (MAXLUN*8);
	dev = MKDEV(ctl,0);

#ifdef	DEBUG
	if( DebugM360 > 3 )
		m360print(dev, "intr");
#endif

	if( m360_addr[ctl] == NULL ) {
#ifdef	DEBUG
		m360print( dev, "Unexpected interrupt" );
#endif
		return;
	}

	rp = (struct device *) m360_addr[ctl];

	/*
	 *	Command completion interrupt
	 */

	csr = rp->csr;			/* save original for error logging */
	if( rp->csr & DONE_INT ) {

		rp->csr &= ~DONE_INT;	/* clear interrupt */

		if( (dp = m360ctlr[ctl].cc_actp) == NULL ) { /* ctlr active? */
			/* log illegal interrupt */
			return;
		}

		if( (bp = dp->b_actf) == NULL ) { /* drive active? */
			/* assert this must never be true */
#ifdef DEBUG
			m360print( dp->b_dev, "lost request, cannot be" );
#endif
			return;
		}


		dp->wtime = WOK;	/* cancel m360timer */
		bp->b_resid = 0;	/* default no error indication */
		bp->cylin = 0;		/* clear cylinder number */
		dev = bp->b_dev;	/* logical dev being serviced */
		pbp = (struct m360iopb *)dp->cmdbuf;

		/* if command completed ok with exception */
		if( pbp->pb_stat == DONE_EXC ) {

			/* log soft error, with block offset to the I/O */
			m360elog(rp, dp, IO_BOFF, csr);

		/* else if status indicates a serious error */
		} else if( pbp->pb_stat != DONE_OK ) {

			/* log error, with block offset to the I/O */
			m360elog(rp, dp, IO_BOFF, csr);

			/* if try count not exhausted, retry */
			if( --dp->b_errcnt > 0 ) {
#ifdef DEBUG
				if(DebugM360) {
					m360print(dev, "M360: Soft Error\n");
					printf(" Block Offset %d\n",(IO_BOFF));
				}
#endif
				m360dstart( dp );
				return;
			}

			/* hard error */
			erf++;
			m360print(dev, "M360:Error");
			m360prall(rp);

			/* indicate error in request buffer */
			bp->b_resid = bp->b_bcount;
			bp->b_flags |= B_ERROR;
		}

		logberr( dp, erf);	/* close error log on this request */


		/* dequeue buffer */
		dp->b_actf = bp->av_forw;
		dp->qcnt--;
		if (bp == (struct buf *)dp->acts)
			dp->acts = (int)dp->b_actf;

		/* log read/write I/O times */
		if( !( bp->b_flags & NON_RWIO) )
		{	register struct iotime *ip = &m360stat[POS(dev)];

			ip->io_resp += lbolt - bp->b_start;
			ip->io_act += lbolt - dp->io_start;
		}

		/*
		 *	notify requestor I/O completed and free buffer
		 */

#ifdef COALES

		coalbp = bp->av_back;
		while(coalbp){ 
			coalbp->b_resid = bp->b_resid;
			coalbp->b_flags |= bp->b_flags & B_ERROR;
			oldbp = coalbp;
	    	        coalbp = coalbp->av_back;
			iodone(oldbp);
		}
#endif

		iodone(bp);
			
		/* start next I/O */
		m360start(ctl);
		return;
	}


	/*
	 *	Status change interrupt
	 */

	if( rp->csr & SCHG_INT ) {
		register drive;

		/* read new status for specified drive */
		drive = SCDRV( rp->csr );	/* identify drive */
		m360utab[ POS( MKDEV(ctl,drive) ) ].dstat = rp->ds[drive];

		rp->csr &= ~SCHG_INT;	/* clear interrupt */
	}
}


/*
 *	m360breakup: Physical I/O Breakup routine
 */

m360breakup(bp)
register struct buf *bp;
{
	dma_breakup(m360strategy, bp, BSIZE);
}


/*
 *	m360read: raw I/O read entry point
 */

m360read(dev)
register dev;
{	
#ifdef	DEBUG
	if( DebugM360 )
		m360print(dev, "read");
#endif

	if(physck(m360_sizes[m360types[LPOS(dev)]][SLICE(dev)].nblocks,B_READ))
		physio(m360breakup, 0, dev, B_READ);
}



/*
 *	m360write: raw I/O write entry point
 */

m360write(dev)
register dev;
{
#ifdef	DEBUG
	if( DebugM360 )
		m360print(dev, "write");
#endif

	if(physck(m360_sizes[m360types[LPOS(dev)]][SLICE(dev)].nblocks,B_WRITE))
		physio(m360breakup, 0, dev, B_WRITE);
}

/*
 *	m360ioctl: ioctl(2) support for the m360
 *
 *	Supported functions:
 *
 *		Format Track
 *		Format Unit
 *		Get Config
 *		Set Config (must supply cf_gpl3 for formatting)
 *		Format Alternate
 */

m360ioctl(dev, cmd, arg, mode)
register dev;		/* device */
register cmd;		/* ioctl command */
register char *arg;	/* ctl args */
register mode;		/* mode */

{	
	register struct iobuf *dp;
	register struct buf *bp;
	register struct m360uib *ibp;
	register m360fmt *fmtp;
	register openmask;
	struct m360config cf;
	struct buf *geteblk();

#ifdef DEBUG
	if  ( DebugM360 )
	    m360print( dev, "ioctl" );
#endif

	dp = &m360utab[POS(dev)];
	ibp = (struct m360uib *)dp->uib;

	/*  linesw table guarantees char device, So check for slice 7 */
	if  (  SLICE(dev)  !=  7 ) {
	       u.u_error = EINVAL;
	       return;
	}
	bp = geteblk();
	fmtp = (m360fmt *)bp->b_un.b_addr;


	switch( cmd )  {

	case M360SET:	/*  Set configuration */
			if ( (copyin( (struct m360config *)arg, &cf, sizeof(struct m360config) ) ) == -1 ) {
				u.u_error = EINVAL;
				brelse(bp);
				return;
			}
			openmask = ( 1 << ((VOL(dev)? 24:8)+SLICE(dev)));
			if ( m360setcf( dev, dp, &cf, openmask )  ) {
				u.u_error = EINVAL;
				brelse(bp);
				return;
			}
			bp->b_flags |= B_CONF;	/* dev points to Vol */
			bp->b_blkno = 0;
			break;

	case M360GET:	/*  Get configuration */
			cf.cf_vsh = ibp->ib_sh( VOL(dev) );
			cf.cf_vnh = ibp->ib_nh( VOL(dev) );
			cf.cf_spt = ibp->ib_spt;
			cf.cf_skew = ibp->ib_skew;
			cf.cf_bps = ibp->ib_bps;
			cf.cf_gap1 = ibp->ib_gap1;
			cf.cf_gap2 = ibp->ib_gap2;
			cf.cf_intlv = ibp->ib_intlv;
			cf.cf_retry = ibp->ib_retry;
			cf.cf_cyls = ibp->ib_cyls;
			cf.cf_attrib = ibp->ib_attrib;
			if  ( (copyout( &cf, (struct m360config *)arg, sizeof(struct m360config) ) ) == -1) {
	       			u.u_error = EINVAL;
				brelse(bp);
				return;
			}
			brelse(bp);
			return;
			
			

	case M360FMTT:	/*  Format Track */		
			if  ( (copyin( (m360fmt *)arg, fmtp, sizeof(m360fmt))) == -1) {
	       			u.u_error = EINVAL;
				brelse(bp);
				return;
			}
			bp->b_blkno = ibp->ib_bps*ibp->ib_spt/BSIZE * fmtp->f_trk;  /* For strategy */
			bp->b_flags |= B_FORMAT;
			break;

	case M360MPT:	/*  Map Alternate track */		
			if  ( (copyin( (m360fmt *)arg, fmtp, sizeof(m360fmt))) == -1) {
	       			u.u_error = EINVAL;
				brelse(bp);
				return;
			}
			bp->b_blkno = ibp->ib_bps*ibp->ib_spt/BSIZE * fmtp->f_trk;  /* For strategy */
			bp->b_flags |= ( B_FORMAT | B_FMTA );
			break;

	case M360MPS:	/*  Sector slip on track */ /* UNTESTED */
			if  ( (copyin( (m360fmt *)arg, fmtp, sizeof(m360fmt))) == -1) {
	       			u.u_error = EINVAL;
				brelse(bp);
				return;
			}
			bp->b_blkno = ibp->ib_bps*ibp->ib_spt/BSIZE * fmtp->f_trk;  /* For strategy */
			bp->b_flags |= ( B_FORMAT | B_FMTS );
			break;

	default:	u.u_error = EINVAL;
			brelse(bp);
			return;
	}

	bp->b_proc = u.u_procp;
	bp->b_dev = dev;
	bp->b_bcount = 0;
	bp->b_error = 0;
	m360strategy(bp);
	iowait(bp);
	/* clear the flags THIS routine wrote */
	bp->b_flags &= ~( B_FORMAT | B_FMTA | B_FMTS | B_CONF );  
	brelse(bp);
	return;
}

/*
 *	m360timer: periodically check on the state of the driver
 */

m360timer(cmd)
register cmd;
{
	static timeron;		/* timer on flag */
	register queued = 0;
	register ctl, pos;
	register struct iobuf *dp;
	register struct buf *bp;

#ifdef	DEBUG
	if( DebugM360 > 4 )
		m360print( 0, "timer");
#endif

	if( cmd == WSTART ) {
		if( timeron )
			return;
		timeron++;
	} else if( ! timeron )
			return;

	/* check each physical drive to insure no request is hung */
	for( pos=0, dp = &m360utab[0]; pos < MAXPOS; pos++, dp++ ) {

		ctl = pos/MAXDEV;
		if( dp->b_actf != NULL ) {
			queued++;
			if( m360ctlr[ctl].cc_actp == NULL ) { /* ctl active? */
#ifdef DEBUG
				printf("MVME360 controller %d not active but should be\n", ctl);
				printf("drive %d has I/O queued\n", pos%MAXDEV);
#endif
				m360start(ctl);
			}
		}

		if( dp->wtime == WOK )	/* nothing to do */
			continue;


		if( dp->wtime-- == WABORT ) {
			logberr(dp, B_ERROR);
			while (bp = dp->b_actf) {
				bp->b_flags |= B_ERROR;
				dp->b_actf = bp->av_forw;
				bp->cylin = 0;
				iodone(bp);
			}
			dp->b_active = 0;
			dp->b_errcnt = 0;
			dp->qcnt = 0;
			printf("MVME360 controller %d, drive %d not available\n",
					pos/MAXDEV, pos%MAXDEV );
		}
	}

	if( queued )	/* some I/O queued? */
		/* wake up every WSECS seconds */
		timeout( m360timer, WCONT, WSECS*HZ );
	else
		timeron = 0;
}


/*
 *	m360elog: performs error logging
 */

#ifdef DEBUG
	int m360ecnt;		/* (soft) error counter */
#endif

m360elog(rp, dp, blkoff, csr)
register struct device *rp;
register struct iobuf *dp;
int csr, blkoff;
{	
	register struct m360iopb *pbp;
	register struct m360eregs *erp;

	pbp = (struct m360iopb *)dp->cmdbuf;
	erp = (struct m360eregs *)dp->io_addr;

	erp->er_blkoff = blkoff;	/* block offset of error */
	erp->d0erstat = rp->drv0stat;	/* drive status */
	erp->d1erstat = rp->drv1stat;

	/* csr passed this way because it changes on interrupt clear */
	erp->er_csr = csr;		/* control status register */
	erp->er_cmd = pbp->pb_cmd;	/* command */
	erp->er_opt = pbp->pb_opt;	/* command option */
	erp->er_stat = pbp->pb_stat;	/* status code */
	erp->er_err = pbp->pb_err;	/* error code */
#ifdef DEBUG
	m360ecnt++;			/* error counter */
#endif
	/* get major number of block device for error logging */
	dp->b_dev = makedev( M360, minor(dp->b_dev));

	fmtberr( dp, 0 ); 		/* post to error log */
}



/*
 *	m360print: perform mvme360 driver standard format printing
 */

m360print(dev,str)
register dev;
char *str;
{	
	printf("%s on MVME360 ctl %d, drive %d, vol %d, slice %d\n", str, 
			CTL(dev), UNIT(dev), VOL(dev), SLICE(dev));
}



/*
 *	m360prall: display all command and status info
 *		for indicated controller
 */

m360prall(rp)
register struct device *rp;
{	
	register struct m360iopb *pbp;
	register done = FALSE;

	pbp = &rp->iopb1;

	while( ! done ) {			/* for each iopb */

		m360prpb(pbp);			/* display iopb */

		/* done if link bit not set or next iopb address is NULL */
		if( (pbp->pb_opt & LINK_IOPB) || 
			( (pbp = pbp->pb_iopbp) == NULL) ) 
			done = TRUE;
	}

	m360prcsr(rp);		/* display control and status registers */
}

/*
 *	m360prpb: display command and status info
 *		for iopb pointed to by pbp argument
 */

m360prpb(pbp)
register struct m360iopb *pbp;
{	
	register unsigned char c, s, e;
	int goodstat;

	/* command */
	printf(" CMD:     ");
	switch( c = pbp->pb_cmd ) {
	case DIAGNOS:	printf(" Execute power up diagnostics ");	break;
	case READ_LNG:	printf(" Read data & ECC for diagnostics ");	break;
	case WRIT_LNG:	printf(" Write data & ECC for diagnostics ");	break;
	case READ_HDR:	printf(" Read random header on current cyl ");	break;
	case GET_CNFG:	printf(" Return current drive params (UIB) ");	break;
	case WRIT_SBF:	printf(" Write diagnostic sector to ctlr ");	break;
	case READ_SBF:	printf(" Read sector written with WRIT_SBF ");	break;
	case READ_SEC:	printf(" Read sector(s) ");			break;
	case WRIT_SEC:	printf(" Write sector(s) ");			break;
	case VRFY_SEC:	printf(" Verify sector(s) ");			break;
	case FMT_TRK:	printf(" Format track ");			break;
	case MAP_TRAK:	printf(" Format out bad track ");		break;
	case HNDSHAKE:	printf(" Handshake controller ");		break;
	case INIT_DRV:	printf(" Initialize drive params ");		break;
	case RESTORE: 	printf(" Attempt to clear drive fault(s) ");	break;
	case SEEK: 	printf(" Seek to specified position ");		break;
	case REFORMAT:	printf(" Format trk saving bad spot mapping ");	break;
	case FMT_TRKD:	printf(" Format track with data ");		break;
	case MAP_SECT:	printf(" Format out bad sector on track ");	break;
	case READ_NOC:	printf(" Read sectors no cache ");		break;
	case VRFY_TRK:	printf(" Verify track ");			break;
	case TRACK_ID:	printf(" Return track header info ");		break;
	case FETCH_EX:	printf(" Fetch IOPB and execute ");		break;
	case SCATTER:	printf(" Scatter read data");			break;
	case GATHER:	printf(" Gather write data");			break;
	default:	printf(" Unrecognized command 0x%x ", c );
			break;
	}

	/* packet status */
	goodstat = TRUE;
	switch( s = pbp->pb_stat ) {
	case DONE_OK:	printf(" --  completed with no error ");	break;
	case BUSY_OK:	printf(" --  in progress ");			break;
	case DONE_ERR:	printf(" --  completed with error ");		break;
	case DONE_EXC:	printf(" --  completed with exception ");	break;
	case UNSTARTED:	printf(" --  unstarted ");			break;
	default:	printf(" Unrecognized status 0x%x ", s );
			goodstat = FALSE;
			break;
	}	
	printf("\n");

	/* error codes */
	if( s == DONE_ERR ) {
		printf(" ERROR:   ");
		switch( e = pbp->pb_err ) {
		case DRV_NRDY:	printf(" Drive not ready ");			break;
		case SEEK_CYL:	printf(" Seek error - wrong cylinder ");	break;
		case ECC_CODE:	printf(" ECC code discrpancy ");		break;
		case BAD_CMD:	printf(" Invalid command code (byte 0 of IOPB) ");	break;
		case BAD_FEX:	printf(" Illegal fetch and execute attempted ");	break;
		case BIG_SNUM:	printf(" Sector number too large for drive ");	break;
		case MEM_TYPE:	printf(" Illegal memory type specified ");	break;
		case BUS_TOUT:	printf(" Bus not available in < 1 ms ");	break;
		case HDR_CHKS:	printf(" Header checksum error ");		break;
		case WRT_PERR:	printf(" Disk write protected ");		break;
		case NOT_SEL:	printf(" No response from unit on select ");	break;
		case SERR_TOUT:	printf(" No correct seek 3 secs after RESTORE ");	break;
		case FLT_TOUT:	printf(" Fault not cleared 3 secs after RESTORE ");	break;
		case DRV_FLT:	printf(" Drive fault occured, RESTORE required ");	break;
		case RDY_TOUT:	printf(" Drive not ready 3 secs after RESTORE ");	break;
		case PAST_END:	printf(" Multi sector I/O exceeded end of media ");	break;
		case UIB_ZERO:	printf(" UIB for specified volume contains zeros ");	break;
		case HDR_PAD:	printf(" Bad post header pad byte found ");	break;
		case FIX_FAIL:	printf(" Failed to fix uncorrectable error ");	break;
		case BAD_CYLX:	printf(" Logical sector num -> bad cylinder num ");	break;
		case BAD_HDX:	printf(" Logical sector num -> bad head num ");	break;
		case BAD_SECX:	printf(" Logical sector num -> bad phys sector num ");	break;
		case OVERRUN:	printf(" Data overrun - suspect clock from drive ");	break;
		case NO_INDEX:	printf(" No index pulse after 65ms on format cmd ");	break;
		case SEC_NFND:	printf(" Sector not found during read or write ");	break;
		case BAD_HDNO:	printf(" Head number in header wrong ");	break;
		case DATA_SYNC:	printf(" Sync word in data field not valid ");	break;
		case SEEK_TOUT:	printf(" Seek not complete in 500ms ");	break;
		case BUSY_TOUT:	printf(" Drive held by dual port over 500ms ");	break;
		case OFF_CYL:	printf(" Not on cylinder 3 secs after select ");	break;
		case RTZ_TOUT:	printf(" Not normal complete 3 secs after RESTORE ");	break;
		case HDR_SYNC:	printf(" Sync word in header not valid ");	break;
		case NOT_INIT:	printf(" Write or format attempted before INIT_DRV ");	break;
		case SMALL_GAP:	printf(" Specified gap too small - minimun gap is 5 ");	break;
		case SEEK_DRV:	printf(" Seek error reported by drive ");	break;
		case MAP_NOP:	printf(" No sector pulse on track to be mapped ");	break;
		case BAD_SPT:	printf(" Sectors per track in UIB invalid ");	break;
		case BIG_SEC:	printf(" Bytes per sector in UIB > buffer size ");	break;
		case BAD_ILV:	printf(" Invalid interleave in UIB > SPT or 0 ");	break;
		case HEAD_OR:	printf(" Head number in IOPB out of range per UIB ");	break;
		case CYL_OR:	printf(" Cylinder no. in IOPB out of range per UIB ");	break;
		case IOPB_FAIL:	printf(" Bus error on external IOPB transfer ");	break;
		case DMA_FAIL:	printf(" Bus error on DMA transfer ");	break;
		case ALLIGN:	printf(" VME buffer address not alligned ");	break;
		case NOSPARE:	printf(" Spare sector already in use ");	break;
		case NOSPARES:	printf(" UIB indicates no spares enabled ");	break;
		case NOT_YET:	printf(" Command not implemented ");		break;
		default:	printf(" Unexpected error code 0x%x ", e );	break;
		}	
		printf("\n");

		/*	Call Motorola Corp for error codes f0-fe. */
		if(e > 0xf0  &&  e < 0xff)
			printf("Call manufacturer with IOPB and UIB info.\n");
	}

	/* exception codes */
	if( s == DONE_EXC ) {

		printf(" EXCEPTION:");
		e = pbp->pb_err;

		if( e &= RTRYMSK ) {		/* if retries used */
			printf(" %d", e);
			if( e == RTRYMSK ) printf(" or more");
			printf(" retries ");
		}
		prbits( pbp->pb_err, BYTEMSB, EXCPMSK, excode );
		printf("\n");
	}

	/* command options */
	{	register unsigned char co;

		co = pbp->pb_opt;
		printf(" CMD_OPTS: Unit %d  Vol %d", COPTOU(co), COPTOV(co));
		prbits( co, BYTEMSB, COPMSK, copdis );
		printf("\n");
	}

	/* if status is recognized display details*/
	if( goodstat ) {
		/* REFORMAT is the same but would also return a fmt_pattern */
		if(  (c == FMT_TRK) || (c == MAP_TRAK) || (c == MAP_SECT) )  {
			printf("  Cylinder 0x%x  head 0x%x   sector 0x%x \n",
				pbp->pb_cyl, pbp->pb_trk, pbp->pb_psect);
			printf("  Sectors formatted  0x%x \n", pbp->pb_scnt);
		}
		else {
			printf("  Logical_sector 0x%x \n", pbp->pb_lsect);
			printf("  Sector_count 0x%x  buffer address 0x%x\n",
				pbp->pb_scnt, pbp->pb_badr);
		}

		if( pbp->pb_iopbp )
			printf("  Next IOPB address 0x%x\n", pbp->pb_iopbp);
	}

	/* if uib used */
	if( c == INIT_DRV || c == GET_CNFG )
		m360pruib((struct m360uib *)pbp->pb_badr); /* display uib */
}

/*
 *	m360pruib: display unit initialization block info
 *		for uib pointed to by ibp argument
 */

m360pruib(ibp)
register struct m360uib *ibp;
{	
	printf(" UIB:");
	printf("  Vol_0 starting_head 0x%x  head_count 0x%x\n",
		ibp->ib_sh(0), ibp->ib_nh(0));
	printf("  Vol_1 starting_head 0x%x  head_count 0x%x\n",
		ibp->ib_sh(1), ibp->ib_nh(1));
	printf("  Sectors_per_trk 0x%x  spiral_skew 0x%x  bytes_per_sect 0x%x\n",
		ibp->ib_spt, ibp->ib_skew, ibp->ib_bps);
	printf("  Gap1 0x%x  gap2 0x%x  sector_interleave 0x%x\n",
		ibp->ib_gap1, ibp->ib_gap2, ibp->ib_intlv);
	printf("  Retry_cnt 0x%x  cylinders 0x%x\n",
		ibp->ib_retry, ibp->ib_cyls);
	prbits( ibp->ib_attrib, BYTEMSB, ATRMSK, atrdis );
	printf("  Reserved 0x%x  status_chg_int_lvl 0x%x  vector 0x%x\n",
		ibp->ib_r0, ibp->ib_silev, ibp->ib_sivec);
}

/*
 *	m360prcsr: display control and status register 
 *		and drive status info for indicated controller
 */

m360prcsr(rp)
register struct device *rp;
{	
	register unsigned csr,d;
	register i;

	csr = rp->csr;
	printf(" CSR:     ");
	prbits( csr, WORDMSB, CSRMSK, csrdis );
	if(csr & SCHG_INT) {
		printf(" stat_chg_drv_");
		if(csr & SCHG_SRC)
			printf("1");
		else
			printf("0");
		}
	printf("\n");

	/* if drive status is non-zero, display it */
	for( i=1; i>=0; --i) {
		if( d = rp->ds[i] ) {
			printf(" DRIVE_%d: ",1-i);
			prbits( d, BYTEMSB, DRVSMSK, dstatdis );
			printf("\n");
		}
	}

#ifdef DEBUG
	/* csr dump */
	if( DebugM360 > 5 ) {
		printf(" CSR_DUMP: d0_stat=0x%x  d1_stat=0x%x  csr=0x%x\n",
			rp->drv0stat, rp->drv1stat, csr);
	}
#endif
}

/*
 *	prbits: prints strings from msgs[] array
 *		for each bit set in both reg and mask
 *		starting at most significant bit msb
 */

STATIC prbits( reg, msb, mask, msgs )
register unsigned int reg, msb, mask;
register char *msgs[];
{
	register i,m;

	for(i=msb, m=1<<msb; i>=0; --i, m>>=1) {
		if((m&mask)&reg)
			printf("%s", msgs[i]);
	}
}



/*
 *	m360clr: clear the driver after powerfail
 */

m360clr()

{	
	/* no hardware to support this function... no warm start */
		/* reboot required after power fail */
}



/*
 *	mvme360 dump support.
 */

m360dump()
{	
}
